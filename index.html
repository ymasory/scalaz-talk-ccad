<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <title>Functors, Monads, and Other Scary Words: Programming with Scalaz</title>
        <link type="text/css" rel="stylesheet" href="assets/css/show.css" />
        <link type="text/css" rel="stylesheet" href="assets/css/prettify.css" />
        <script type="text/javascript" src="assets/js/jquery.min.js"></script>
        <script type="text/javascript" src="assets/js/show.js"></script>
        <script type="text/javascript" src="assets/js/prettify/prettify.js"></script>
        <script type="text/javascript" src="assets/js/prettify/lang-apollo.js"></script><script type="text/javascript" src="assets/js/prettify/lang-css.js"></script><script type="text/javascript" src="assets/js/prettify/lang-hs.js"></script><script type="text/javascript" src="assets/js/prettify/lang-lisp.js"></script><script type="text/javascript" src="assets/js/prettify/lang-lua.js"></script><script type="text/javascript" src="assets/js/prettify/lang-ml.js"></script><script type="text/javascript" src="assets/js/prettify/lang-proto.js"></script><script type="text/javascript" src="assets/js/prettify/lang-scala.js"></script><script type="text/javascript" src="assets/js/prettify/lang-sql.js"></script><script type="text/javascript" src="assets/js/prettify/lang-sql.js"></script><script type="text/javascript" src="assets/js/prettify/lang-vb.js"></script><script type="text/javascript" src="assets/js/prettify/lang-vhdl.js"></script><script type="text/javascript" src="assets/js/prettify/lang-wiki.js"></script><script type="text/javascript" src="assets/js/prettify/lang-yaml.js"></script><link type="text/css" rel="stylesheet" href="css/custom.css?1338514286722" />
      <script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
      </head>
      <body>
        <div id="slides">
          <div id="reel">
            <div class="content" id="slide-0">
       <div class="container"><h1 id="Functors%2C+Monads%2C+and+Other+Scary+Words">Functors, Monads, and Other Scary Words</h1><h1 id="Programming+with+Scalaz">Programming with Scalaz</h1><ul><li>Yuvi Masory
</li><li>May 21, 2012
</li><li>CCAD
</li></ul><p><img alt="pic" title="scalaz code" src="main/scary.png" />
</p></div>
      </div><div class="content" id="slide-1">
       <div class="container"><h1 id="Scalaz+7">Scalaz 7</h1><ul><li>More modular
</li><li><em>Much</em> more discoverable
</li><li>Unicode is (mostly) gone
</li><li>Still poorly documented
</li></ul></div>
      </div><div class="content" id="slide-2">
       <div class="container"><h1 id="I.+You+don%E2%80%99t+need+to+use+functional+programming+to+benefit+from+Scalaz%21">I. You don’t need to use functional programming to benefit from Scalaz!</h1></div>
      </div><div class="content" id="slide-3">
       <div class="container"><h1 id="1.+Scalaz+has+lots+of+random+utilities+%28although+could+use+some+more+%E2%80%A6%29">1. Scalaz has lots of random utilities (although could use some more …)</h1></div>
      </div><div class="content" id="slide-4">
       <div class="container"><h1 id="Random+utilities">Random utilities</h1><pre><code class="">&quot;1&quot;.toInt
&quot;foo&quot;.toInt //uh-oh

val iOpt: Option[Int] = &quot;foo&quot;.parseInt
println(iOpt.isDefined ? &quot;parsed&quot; | &quot;unparseable&quot;)
</code></pre></div>
      </div><div class="content" id="slide-5">
       <div class="container"><h1 id="2.+Scalaz+has++alternatives+to+Java+legacies.">2. Scalaz has <em>better</em> alternatives to Java legacies.</h1></div>
      </div><div class="content" id="slide-6">
       <div class="container"><h1 id="Considered+Harmful"><code>==</code> Considered Harmful</h1><pre><code class="">val admin: Option[User] = //...
val curUser: User = //...
if (curUser == admin) { //oops! always false
  //...
}
</code></pre></div>
      </div><div class="content" id="slide-7">
       <div class="container"><h1 id="Considered+Awesome"><code>===</code> Considered Awesome</h1><pre><code class="">implicit def userEqual = equalA[User]
if (curUser === admin) { //doesn't compile!
  //...
}
</code></pre></div>
      </div><div class="content" id="slide-8">
       <div class="container"><h1 id="3.+Scalaz+has++alternatives+to+many+Scala+constructions.">3. Scalaz has <em>safer</em> alternatives to many Scala constructions.</h1></div>
      </div><div class="content" id="slide-9">
       <div class="container"><h1 id="Considered+Annoying"><code>List#head</code> Considered Annoying</h1><pre><code class="">//my startup
val payingCustomers: List[Customer] = //...
val customer = payingCustomers.head //throws exception!
</code></pre><p>Empty lists don’t have a head.
</p></div>
      </div><div class="content" id="slide-10">
       <div class="container"><pre><code class="">//my business
class Customer {
  def creditCards: List[String]
}
object Customer {
  def mkCustomer(name: String, creditCard: String, creditCards: String*): Customer = ...
}
someCustomer.creditCards.headOption match {
  case Some(creditCard) =&gt;  //now that's annoying
  case None
}
</code></pre><p>Checking for empty lists is unnecessary in many cases. But who knows which ones?
</p></div>
      </div><div class="content" id="slide-11">
       <div class="container"><h1 id=""><code>scalaz.NonEmptyList</code></h1><pre><code class="">NonEmptyList(1)
NonEmptyList(1, 2, 3)
NonEmptyList(0) //doesn't compile!

val lst: NonEmptyList[Int] = ...
lst.head //completely safe
</code></pre></div>
      </div><div class="content" id="slide-12">
       <div class="container"><h1 id="II.+The+Typeclass+Pattern">II. The Typeclass Pattern</h1><p>You may have noticed this strange bit
</p><pre><code class="">implicit def userEqual = equalA[User]
</code></pre></div>
      </div><div class="content" id="slide-13">
       <div class="container"><h1 id="What+are+types%3F">What are types?</h1><p>A simple definition: types are collections of <em>expressions</em>.
</p><h2 id="Polymophism">Polymophism</h2><p>Because we want our functions to work on many types.
</p><h2 id="Ad-hoc+polymorphism">Ad-hoc polymorphism</h2><p>Polymorphic functions may do something different depending on its input type.
</p></div>
      </div><div class="content" id="slide-14">
       <div class="container"><h1 id="Ad-hoc+polymorphism+using+inheritance+%26+subtyping">Ad-hoc polymorphism using inheritance &amp; subtyping</h1><pre><code class="">trait Equal[A] {
  def ===(a: A): Boolean
}
case class Person(name: String, zip: Int) extends Equal[Person] {
  def ===(that: Person) = //...
}
Person(&quot;yuvi&quot;, 19104) === Person(&quot;colleen&quot;, 12345)
</code></pre></div>
      </div><div class="content" id="slide-15">
       <div class="container"><h1 id="Not+bad.+But+what+if+%E2%80%A6">Not bad. But what if …</h1><ul><li>… you don’t control the <code>Person</code> source code?
</li><li>… you want more than one equality notion?
</li><li>… you want your domain objects “light” and free of behavior?
</li><li>… you want method implementations to be fully known at compile time?
</li><li>… you want to leave the interface “open” so you can add new implementations later without re-jiggering a type hierarchy
</li></ul></div>
      </div><div class="content" id="slide-16">
       <div class="container"><h1 id="Ad-hoc+polymorphism+using+typeclasses">Ad-hoc polymorphism using typeclasses</h1><pre><code class="">trait Equal[A] {
  def(a1: Equal, a2: Equal): Boolean
}
object PersonEqual extends Equal[Person] {
  def equals(p1: Person, p2: Person): Boolean = //...
}
PersonEqual equals (Person(&quot;yuvi&quot;, 19104), Person(&quot;colleen&quot;, 12345))
</code></pre></div>
      </div><div class="content" id="slide-17">
       <div class="container"><h1 id="Now+with+some+sugar">Now with some sugar</h1><pre><code class="">trait Equal[A] {
  def(lhs: A, rhs: A): Boolean
}
object Equal {
  implicit def addEqualOps[A:Equal](lhs: A) = new EqualOps(lhs)
}
class EqualOps[A](lhs: A)(implicit ev: Eq[A]) {
  def ===(rhs: A) ev.eq(lhs, rhs)
}
implicit object PersonEqual extends Equal[Person] {
  def equals(p1: Person, p2: Person): Boolean = //...
}

import Equal._
p1 === p2
</code></pre></div>
      </div><div class="content" id="slide-18">
       <div class="container"><h1 id="Note+this+is+a+brand+new+type+relationship">Note this is a brand new type relationship</h1><pre><code class="">//&quot;is-a&quot;
def mycompare[A &lt;: Comparable](lhs: A, rhs: A) = lhs compare rhs

//&quot;has-a&quot;
def myequal[A:Equal](lhs: A, rhs: A) = lhs equals rhs

//&quot;has-a&quot;, de-sugared, note &quot;ev&quot; is never used
def myequal[A](lhs: A, rhs: A)(ev: Equal[A]) = lhs equals rhs
</code></pre></div>
      </div><div class="content" id="slide-19">
       <div class="container"><h1 id="Advantages+of+typeclasses">Advantages of typeclasses</h1><ul><li>No dynamic dispatch, implementations known to compiler.
</li><li>Behavior is de-coupled from domain object, AND
</li><li>Behavior is de-coupled from inheritance, leaving the trait “open”
</li><li>Multiple typeclass instances can exist side-by-side
</li></ul><h1 id="Disadvantages+of+typeclasses">Disadvantages of typeclasses</h1><ul><li>Boilerplate (for now)
</li><li>Run-time overhead of wrapper object creation (for now)
</li></ul></div>
      </div><div class="content" id="slide-20">
       <div class="container"><h1 id="More+on+typeclasses">More on typeclasses</h1><ul><li>Seth Tisue’s NE Scala Talk (video): http://bit.ly/He7rgq
</li><li>Erik Osheim’s PHASE talk (slides): http://bit.ly/pbsukl
</li></ul></div>
      </div><div class="content" id="slide-21">
       <div class="container"><h1 id="III.+Let%E2%80%99s+get+to+some+real+functional+programming+%E2%80%A6">III. Let’s get to some real functional programming …</h1><p><img alt="pic" title="don't panic" src="main/dontpanic.jpg" />
</p><h1 id="You+already+do+all+these+things+%E2%80%A6">You already do all these things …</h1></div>
      </div><div class="content" id="slide-22">
       <div class="container"><h1 id="Functors">Functors</h1><p>Let’s keep it simple: if you can map over it, it’s a functor.
</p><pre><code class="">trait Functor[F[_]] {
  def map[A, B](r: F[A], f: A =&gt; B): F[B]
}
</code></pre></div>
      </div><div class="content" id="slide-23">
       <div class="container"><h1 id="is+a"><code>Option</code> is a <code>Functor</code></h1><pre><code class="">object OptionIsFunctor: Functor[Option] = new Functor[Option] {
  def map[A, B](r: Option[A], f: A =&gt; B) = r match {
    case None =&gt; None
    case Some(a) =&gt; Some(f(a))
  }
}
</code></pre></div>
      </div><div class="content" id="slide-24">
       <div class="container"><h1 id="is+a"><code>List</code> is a <code>Functor</code></h1><pre><code class="">object ListIsFunctor: Functor[List] = new Functor[List] {
  def map[A, B](as: List[A], f: A =&gt; B) = as match {
    case Nil =&gt; Nil
    case h :: t =&gt; f(h) :: map(t, f)
  }
}
</code></pre></div>
      </div><div class="content" id="slide-25">
       <div class="container"><h1 id="Applicatives+%28really%2C+Applicative+Functors%29">Applicatives (really, Applicative Functors)</h1><p>No time for this … and not so natural in Scala since functions are not curried by default.
</p><pre><code class="">for {
  url   &lt;- urlOpt
  pw    &lt;- passwordOpt
  uname &lt;- usernameOpt
} yield DriverManager getConnection (url, pw, uname)

(url |@| pw |@| uname) { Driver.getConnection }
</code></pre></div>
      </div><div class="content" id="slide-26">
       <div class="container"><h1 id="Aside%3A+This+is+what+Scala+already+does%2C+although+oddly+without+types+or+a+representation+of">Aside: This is what Scala already does, although oddly without types or a representation of <code>Functor</code></h1><pre><code class="">for (el &lt;- List(1, 2)) yield el + 10

List(1, 2) map { _ + 10 }
</code></pre></div>
      </div><div class="content" id="slide-27">
       <div class="container"><h1 id="Monads">Monads</h1><p><code>Functors</code> that can <code>flatMap</code>
</p><p><img alt="pic" title="monads" src="main/monads.jpg" />
</p></div>
      </div><div class="content" id="slide-28">
       <div class="container"><h1 id="If+we+didn%E2%80%99t+have+monads">If we didn’t have monads</h1><pre><code class="">def perfectRoot(i: Int): Option[Int] = //...
val opt = perfectRoot(10000)
opt map { perfectRoot(_) }
//Some(Some(10))

opt flatMap { perfectRoot(_) }
//Some(10)
</code></pre></div>
      </div><div class="content" id="slide-29">
       <div class="container"><h1 id="Monad">Monad</h1><pre><code class="">trait Monad[M[_]] extends Applicative[M] {
  def pure[A](a: =&gt; A): M[A]
  def flatMap[A, B](a: M[A], f: A =&gt; M[B]): M[B]
}
</code></pre></div>
      </div><div class="content" id="slide-30">
       <div class="container"><h1 id="Monads+you+know">Monads you know</h1><ul><li><code>List</code>
</li><li><code>Option</code>
</li><li><code>Function1</code>
</li></ul></div>
      </div><div class="content" id="slide-31">
       <div class="container"><h1 id="Aside%3A+This+is+what+Scala+already+does%2C+although+oddly+without+types+or+a+representation+of">Aside: This is what Scala already does, although oddly without types or a representation of <code>Monad</code></h1><pre><code class="">for {
  a &lt;- aOpt
  b &lt;- bOpt
  c &lt;- cOpt
} yield a + b + c

aOpt.flatMap { a =&gt;
  bOpt.flatMap { b =&gt;
    cOpt.flatMap { c =&gt;
      a + b + c
    }
  }
}
</code></pre></div>
      </div><div class="content" id="slide-32">
       <div class="container"><h1 id="Monoids">Monoids</h1><p>Things you can add.
</p></div>
      </div><div class="content" id="slide-33">
       <div class="container"><h1 id="Technically%2C+Monoids">Technically, Monoids</h1><ul><li>A monoid is a semigroup with a zero element …
</li><li>A semigroup is a set of elements with the binary operation “plus”
</li><li>Zero is the left and right additive identity …
</li><li>The set is closed over plus.
</li></ul></div>
      </div><div class="content" id="slide-34">
       <div class="container"><h1 id="What+have+we+gained+through+a+formal+representation+of+functors%2C+monads%2C+and+monoids%3F+After+all+these+are+ideas+already+present+in+Scala+and+almost+every+programming+language.">What have we gained through a formal representation of functors, monads, and monoids? After all these are ideas already present in Scala and almost every programming language.</h1></div>
      </div><div class="content" id="slide-35">
       <div class="container"><h1 id="Thank+you+%E2%80%A6+questions%3F">Thank you … questions?</h1></div>
      </div>
          </div>
        </div>
        <script type="text/javascript" src="js/custom.js?1338514287514"></script>
      </body>
    </html>